//проверка, подключен ли файл уже (избежание повторного подключения файла)
#ifndef DEQUE_CPP
#define DEQUE_CPP

#include "Deque.h"
#include <iostream>
#include <string>

using namespace std;

//конструктор с параметром
template <typename T>
Deque<T>::Deque(int size)
{
	arr = new T[size]; //выделяем память под элементы типа Т, то есть типа, который был указан при создании объекта
	for (int i = 0; i < size; ++i) //заполение случайными числами
		arr[i] = rand() % 26 + 65;

	this->size = size; //установка максимального значения дека
	last = size; //заполнили весь дек, а значит текущий размер дека равен максимальному
}

//конструктор копирования
template<typename T>
Deque<T>::Deque(Deque<T>& other)
{
	this->size = other.size; //максимальный размер созданного объекта равен размеру объекта, из которого копируем
	this->last = other.last; //текущий размер созданного объекта равен размеру объекта, из которого копируем
	arr = new T[size]; //выделяем память под элементы созданного объекта

	for (int i = 0; i < this->size; ++i) //копируем все значения в созданный объект
		this->arr[i] = other.arr[i];
}

//деструктор
template <typename T>
Deque<T>::~Deque()
{
	delete[] arr; //удаляем динамически выделенный массив
}

template <typename T>
void Deque<T>::pushFront(T value) //добавление элемента в начало
{
	if (last == size) //если текущий размер равен максимальному, значит дек заполнен полностью
	{
		cout << endl << "Дек заполнен" << endl << endl;
	}
	else
	{
		//если дек не заполнен
		for (int i = last; i > 0; --i) //сдвигаем все элементы массива вправо на один элемент, чтобы добавить новый элемент в начало
			arr[i] = arr[i - 1];

		arr[0] = value; //записываем новый элемент в первую ячейку
		last++; //увеличиваем текущий размер дека
		cout << endl << "Элемент добавлен" << endl << endl;
	}
	system("pause");
}

template <typename T>
void Deque<T>::pushBack(T value) //добавление элемента в конец
{
	if (last == size) //если текущий размер равен максимальному, значит дек заполнен полностью
	{
		cout << endl << "Дек заполнен" << endl << endl;
	}
	else
	{
		//учитываем, что элементы массива начинаются с индекса 0
		arr[last++] = value; //записываем новый элемент в конец, после чего увеличиваем текущий размер дека
		cout << endl << "Элемент добавлен" << endl << endl;
	}
	system("pause");
}

//перегрузка оператора присваивания
template<typename T>
Deque<T>& Deque<T>::operator=(const Deque<T> & other)
{
	this->last = other.last; //приравниваем текущие размеры деков
	for (int i = 0; i < this->last; ++i) //приравниваем каждый элемент массивов
	{
		this->arr[i] = other.arr[i];
	}
	return *this; //возвращаем объект слева от знака
}

//перегрузка бинарного минуса
template<typename T>
Deque<T> Deque<T>::operator+(const Deque<T> & other)
{
	//обработка на исключительную ситуацию
	try {
		//если текущие размеры не совпадают, значит необходимо сгенерировать исключительную ситуацию
		if (this->last != other.last)
		{
			exception ex("Размеры деков не совпадают, сложение невозможно"); //создаем объект класса exception, и записываем в него ошибку
			throw ex; //выбрасываем объект в качестве ошибки
		}
		//если была выбрашена ошибка, строчки с 103 по 110 не будут выполнены
		//если ошибка не была выбрашена, то продолжаем наши дествия дальше
		Deque<T> res(this->size); //создаем объект, в который будем записывать результат сложения
		for (int i = 0; i < this->last; ++i) //производим сложение соответствующих элементов
			res.arr[i] = this->arr[i] + other.arr[i];

		res.last = this->last; //приравниваем текущие размеры

		return res; //возвращаем объект, который содержит результат сложения двух других объектов
	}
	catch (exception & ex) //ловим ошибку
	{
		cout << ex.what() << endl << endl; //выводим ошибку на экран
		system("pause");
		return *this; //возвращаем не измененный объект слева от знака
	}
}

//перегрузка унарного минуса
template<typename T>
Deque<T> Deque<T>::operator-()
{
	Deque<T> res(*this); //создаем объект, в который запишем изменения
	if(res.last > 0) //если дек не пустой, то можно извлекать элементы с конца
		res.last--; //просто уменьшение текущего размера дека, затирать элементы не надо, так как они сами перезатрутся при добавлении нового элемента
	return res; //возвращение измененного объекта
}

//перегрузка сравнения <
template<typename T>
bool Deque<T>::operator<(const Deque<T>& other)
{
	if (this->last < other.last) //если текущий размер объекта слева меньше текущего размера объекта справа, то дек слева меньше, значит true
		return true;
	else if (this->last > other.last) //если текущий размер объекта слева больше текущего размера объекта справа, то дек слева больше, значит false
		return false;
	else //если они равны, то ищем первые различные элементы
	{
		for (int i = 0; i < this->last; i++) //пробигаемся по элементам дека
		{
			if (this->arr[i] > other.arr[i]) //если элемент левого дека больше элемента второго, то значит дек слева не меньше дека справа => false
				return false;
			else if(this->arr[i] < other.arr[i]) //если элемент левого дека меньше элемента второго, то значит дек слева меньше дека справа => true
				return true;
			//если элементы равны, переходим к сравнению следующих элементов
		}
		return false; //если все элементы деков равны, то есть не нашли различных, то левый дек не меньше правого
	}
}

//перегрузка оператора вывода
template<typename T>
ostream & operator<< <>(ostream & out, const Deque<T>& ob)
{
	out << "Дек: ";
	for (int i = 0; i < ob.last; ++i) //выводим каждый элемент дека через пробел
	{
		out << ob.arr[i] << " ";
	}
	out << endl << endl;

	return out; //возвращаем ссылку на поток
}

//перегрузка оператора ввода
template<typename T>
istream & operator>> <>(istream & in, Deque<T>& ob)
{
	int menu;
	T value;
	//выбираем, куда добавить элемент
	cout << "1) Добавить в начало элемент" << endl;
	cout << "2) Добавить в конец элемент" << endl;
	cin >> menu;
	cout << "Введите элемент: ";
	cin >> value; //вводим элемент, который хотим добавить
	switch (menu)
	{
	//вызов добавления элемента в зависимости от того, что выбрано
	case 1: ob.pushFront(value); break;
	case 2: ob.pushBack(value); break;
	}
	return in;
}

#endif